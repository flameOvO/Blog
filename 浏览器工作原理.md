## 浏览器的组成

#### 渲染引擎

-   Firefox：Gecko引擎
-   Safari：WebKit引擎
-   Chrome：Blink引擎
-   IE: Trident引擎
-   Edge: EdgeHTML引擎

#####渲染引擎处理网页

1.  解析代码：HTML代码解析为DOM，CSS代码解析为CSSOM（CSS Object Model）
2.  对象合成：将DOM和CSSOM合成一棵渲染树（render tree）
3.  布局：计算出渲染树的布局（layout）
4.  绘制：将渲染树绘制到屏幕

#### JavaScript引擎

JavaScript引擎的主要作用是，读取网页中的JavaScript代码，对其处理后运行。

浏览器的主要组成：

1.  用户界面 － 包括地址栏、后退/前进按钮、书签目录等，也就是你所看到的除了用来显示你所请求页面的主窗口之外的其他部分。
2.  浏览器引擎 － 用来查询及操作渲染引擎的接口。
3.  渲染引擎 － 用来显示请求的内容，例如，如果请求内容为html，它负责解析html及css，并将解析后的结果显示出来。
4.  网络 － 用来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作。
5.  UI后端 － 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口。
6.  JS解释器 － 用来解释执行JS代码。
7.  数据存储 － 属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML5定义了web database技术，这是一种轻量级完整的客户端存储技术



浏览器首先扫描 HTML 文档，查看有哪些外部资源需要启动 network operation 来请求资源，并在 HTML 解析的同时，发送所有的请求。CSS 资源加载完毕后，会立即开始解析构建 CSSOM。（同步脚本加载完毕后，并不能立刻执行。）当 HTML 解析到`<script>`标签，先确认脚本加载完毕了没，如果没，那得等；如果加载好了，还得看 CSS 解析好了没。如果没，那还得等；如果 CSS 解析好了，那就能把脚本交给 JS 引擎去执行了。当 JS 执行完毕，HTML 继续解析，DOM 继续构建，直到全部构建完成，`DOMContentLoaded` 事件被触发。紧接着，就是构建 render 树。

如果脚本有`async`属性，问题就又不一样了。`async`属性默认该脚本不会影响到 DOM 内容，所以只要脚本下载完成，（相关）CSS 解析完毕，脚本立刻执行，不用等着 HTML 解析到`<script>`标签再开始执行。同样，HTML 也不会等着脚本执行完毕再解析。仿佛两者看不到对方，只管做自己的事情就行了。









1.  浏览器一边下载HTML网页，一边开始解析
2.  解析过程中，发现`<script>`标签
3.  暂停解析，网页渲染的控制权转交给JavaScript引擎
4.  如果`<script>`标签引用了外部脚本，就下载该脚本，否则就直接执行
5.  执行完毕，控制权交还渲染引擎，恢复往下解析HTML网页
6.  Firefox会等到脚本前面的所有样式表，都下载并解析完，再执行脚本；Webkit则是一旦发现脚本引用了样式，就会暂停执行脚本，等到样式表下载并解析完，再恢复执行。







#### defer和async

解决阻塞效应的都是通过在解析HTML的同时并行下载外链脚本

`defer`的运行流程如下。有defer属性的脚本只有**等到DOM加载完成后**，才会**按顺序执行**。

1.  浏览器开始解析HTML网页
2.  解析过程中，发现带有`defer`属性的`script`标签
3.  浏览器继续往下解析HTML网页，同时并行下载`script`标签中的外部脚本
4.  浏览器完成解析HTML网页，此时再执行下载的脚本

`async`属性的作用是，使用另一个进程下载脚本，下载时不会阻塞渲染。**哪个先下完先执行哪个**

1.  浏览器开始解析HTML网页
2.  解析过程中，发现带有`async`属性的`script`标签
3.  浏览器继续往下解析HTML网页，同时并行下载`script`标签中的外部脚本
4.  脚本下载完成，浏览器暂停解析HTML网页，开始执行下载的脚本
5.  脚本执行完毕，浏览器恢复解析HTML网页